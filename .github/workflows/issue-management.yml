name: Issue Management

on:
  issues:
    types: [opened, labeled, unlabeled]
  issue_comment:
    types: [created]
  schedule:
    - cron: '0 9 * * 1' # Every Monday at 9 AM

jobs:
  triage:
    name: Auto-triage Issues
    if: github.event.action == 'opened'
    runs-on: ubuntu-latest
    steps:
      - name: Add triage label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['triage']
            });

      - name: Auto-label based on content
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = context.payload.issue.title.toLowerCase();
            const body = context.payload.issue.body?.toLowerCase() || '';
            const labels = [];
            
            // Bug detection
            if (title.includes('bug') || title.includes('error') || title.includes('issue') || 
                body.includes('error') || body.includes('broken') || body.includes('not working')) {
              labels.push('bug');
            }
            
            // Feature request detection
            if (title.includes('feature') || title.includes('enhancement') || 
                body.includes('feature request') || body.includes('would like')) {
              labels.push('enhancement');
            }
            
            // Documentation
            if (title.includes('docs') || title.includes('documentation') ||
                body.includes('documentation') || body.includes('readme')) {
              labels.push('documentation');
            }
            
            // Priority detection
            if (title.includes('urgent') || title.includes('critical') || 
                body.includes('production') || body.includes('urgent')) {
              labels.push('priority:high');
            }
            
            // Component detection
            const components = {
              'frontend': ['frontend', 'ui', 'react', 'nextjs', 'dashboard', 'web'],
              'backend': ['backend', 'api', 'service', 'server', 'database'],
              'devops': ['deployment', 'docker', 'kubernetes', 'ci/cd', 'pipeline'],
              'security': ['security', 'auth', 'authentication', 'vulnerability']
            };
            
            for (const [component, keywords] of Object.entries(components)) {
              if (keywords.some(keyword => title.includes(keyword) || body.includes(keyword))) {
                labels.push(`component:${component}`);
              }
            }
            
            if (labels.length > 0) {
              github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: labels
              });
            }

  assign-reviewers:
    name: Auto-assign Reviewers
    if: github.event.action == 'labeled'
    runs-on: ubuntu-latest
    steps:
      - name: Assign based on labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelName = context.payload.label.name;
            const assignees = [];
            
            switch(labelName) {
              case 'component:frontend':
                assignees.push('frontend-lead');
                break;
              case 'component:backend':
                assignees.push('backend-lead');
                break;
              case 'component:devops':
                assignees.push('devops-lead');
                break;
              case 'component:security':
                assignees.push('security-lead');
                break;
              case 'priority:high':
              case 'priority:critical':
                assignees.push('project-manager');
                break;
            }
            
            if (assignees.length > 0) {
              github.rest.issues.addAssignees({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                assignees: assignees
              });
            }

  stale-issues:
    name: Mark Stale Issues
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Mark stale issues
        uses: actions/stale@v8
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          stale-issue-message: |
            This issue has been automatically marked as stale because it has not had any activity for 30 days.
            It will be closed if no further activity occurs within 7 days.
            If this is still relevant, please comment or remove the stale label.
          close-issue-message: |
            This issue has been automatically closed due to inactivity.
            If you believe this issue is still relevant, please reopen it or create a new issue.
          stale-issue-label: 'stale'
          days-before-stale: 30
          days-before-close: 7
          exempt-issue-labels: 'pinned,security,priority:high,priority:critical'

  issue-metrics:
    name: Track Issue Metrics
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Generate issue metrics
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              since: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()
            });
            
            const metrics = {
              totalIssues: issues.length,
              openIssues: issues.filter(i => i.state === 'open').length,
              closedIssues: issues.filter(i => i.state === 'closed').length,
              bugs: issues.filter(i => i.labels.some(l => l.name === 'bug')).length,
              enhancements: issues.filter(i => i.labels.some(l => l.name === 'enhancement')).length
            };
            
            console.log('Weekly Issue Metrics:', JSON.stringify(metrics, null, 2));
            
            // You could send this to a monitoring service or Slack here